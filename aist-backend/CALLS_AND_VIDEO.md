# Подключение голосовых и видеозвонков (WebRTC)

Чтобы звонки в мессенджере заработали между двумя устройствами, нужна **сигнализация**: обмен SDP (offer/answer) и ICE-кандидатами между звонящим и принимающим.

## Что уже есть во фронтенде

- Кнопки «Голосовой звонок» и «Видеозвонок» в шапке чата открывают экран звонка (`CallScreen`).
- Локальное видео (камера) при видеозвонке показывается.
- Нет реального соединения с собеседником, пока бэкенд не отдаёт сигналы.

## Что нужно на бэкенде

### 1. WebSocket-сервер (сигнализация)

Поднимите WebSocket-сервер (например, тот же Node.js с `ws` или Socket.IO) на том же домене/порту или отдельном пути.

Рекомендуемые события (имена можно заменить на свои):

| Событие (от клиента) | Назначение |
|----------------------|------------|
| `call:offer`         | Инициатор отправляет SDP offer (и, при необходимости, chatId / userId вызываемого). |
| `call:answer`        | Принимающий отправляет SDP answer. |
| `call:ice`           | Любая сторона отправляет ICE-кандидат. |
| `call:hangup`        | Завершение звонка. |

Сервер должен:

- Проверять JWT (например, из query или первого сообщения) и привязывать соединение к `userId`.
- По `call:offer` с указанием целевого пользователя (или чата) — переслать offer этому пользователю (по его текущему WebSocket).
- Пересылать `call:answer` и `call:ice` второй стороне.
- Пересылать `call:hangup` при отключении.

Пример структуры сообщений:

```json
{ "event": "call:offer", "payload": { "sdp": "...", "chatId": "...", "userId": "target-user-id" } }
{ "event": "call:answer", "payload": { "sdp": "..." } }
{ "event": "call:ice", "payload": { "candidate": { ... } } }
```

### 2. Логика на фронтенде (кратко)

1. При нажатии «Позвонить»: создать `RTCPeerConnection`, при видеозвонке добавить локальный поток с камеры, сгенерировать **offer**, отправить его на сервер через WebSocket (`call:offer`).
2. Принимающая сторона: по получению offer создать `RTCPeerConnection`, установить `setRemoteDescription(offer)`, добавить свой поток (для видео), сгенерировать **answer**, отправить `call:answer`.
3. Обе стороны: при появлении ICE-кандидатов отправлять их через `call:ice` и добавлять у другой стороны через `addIceCandidate`.
4. После установки соединения отображать удалённый поток в `<video ref={remoteVideoRef} autoPlay />` (как уже сделано в `CallScreen` для локального).

### 3. Рекомендации по окружению

- **HTTPS** обязателен в продакшене (WebRTC и камера/микрофон требуют secure context).
- Для продакшена желателен **TURN-сервер** (например, coturn), чтобы звонки работали за симметричным NAT. STUN можно взять публичный (например, `stun:stun.l.google.com:19302`) для тестов.

## Минимальный пример (Node.js + ws)

```bash
npm install ws
```

Отдельный файл или блок в `server.js`:

- Поднять WebSocket-сервер (например, на том же порту через upgrade HTTP или отдельный порт).
- В `connection` парсить JWT из query/headers, сохранять `userId` для сокета.
- Хранить маппинг `userId -> currentSocket`, чтобы пересылать события нужному пользователю.
- При получении `call:offer` с `targetUserId` отправить второму пользователю событие с offer; аналогично для answer и ICE.

После реализации сигнализации остаётся во фронтенде подставить в `CallScreen` вызовы вашего WebSocket-клиента (отправка offer/answer/ICE и установка `remoteDescription` / `addIceCandidate`), после чего звонки начнут подключаться.
