{"ast":null,"code":"/**\n * WebSocket для получения сообщений в реальном времени\n * Улучшенная версия с более надёжной обработкой соединения\n */\nimport { getWsUrl } from './api';\nlet ws = null;\nlet listeners = [];\nlet reconnectTimer = null;\nlet heartbeatTimer = null;\nlet isConnected = false;\nlet isConnecting = false;\nlet pendingMessages = [];\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 10;\nconst RECONNECT_DELAY = 3000; // 3 секунды\n\n/**\n * Подключиться к WebSocket\n */\nexport function connectChatWebSocket(token, onMessage) {\n  if (ws && isConnected) {\n    // Если уже подключены, добавляем слушателя\n    if (onMessage && !listeners.includes(onMessage)) {\n      listeners.push(onMessage);\n    }\n    return;\n  }\n  if (isConnecting) {\n    // Уже пытаемся подключиться\n    if (onMessage && !listeners.includes(onMessage)) {\n      listeners.push(onMessage);\n    }\n    return;\n  }\n  isConnecting = true;\n  const url = `${getWsUrl()}?token=${encodeURIComponent(token)}`;\n  try {\n    ws = new WebSocket(url);\n    ws.onopen = () => {\n      console.log('[ChatWS] Connected');\n      isConnected = true;\n      isConnecting = false;\n      reconnectAttempts = 0;\n\n      // Запускаем heartbeat для поддержания соединения\n      startHeartbeat();\n\n      // Отправляем отложенные сообщения\n      while (pendingMessages.length > 0) {\n        const msg = pendingMessages.shift();\n        ws.send(JSON.stringify(msg));\n      }\n\n      // Оповещаем слушателей о подключении\n      listeners.forEach(listener => {\n        try {\n          listener({\n            type: 'connected'\n          });\n        } catch (e) {\n          console.error('[ChatWS] Error in listener:', e);\n        }\n      });\n    };\n    ws.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('[ChatWS] Received:', data);\n\n        // Обработка heartbeat\n        if (data.type === 'pong') {\n          return;\n        }\n\n        // Оповещаем всех слушателей\n        listeners.forEach(listener => {\n          try {\n            listener(data);\n          } catch (e) {\n            console.error('[ChatWS] Error in listener:', e);\n          }\n        });\n      } catch (e) {\n        console.error('[ChatWS] Error parsing message:', e);\n      }\n    };\n    ws.onclose = event => {\n      console.log('[ChatWS] Disconnected, code:', event.code, 'reason:', event.reason);\n      isConnected = false;\n      isConnecting = false;\n      ws = null;\n      stopHeartbeat();\n\n      // Оповещаем слушателей о отключении\n      listeners.forEach(listener => {\n        try {\n          listener({\n            type: 'disconnected'\n          });\n        } catch (e) {\n          console.error('[ChatWS] Error in listener:', e);\n        }\n      });\n\n      // Автоматическое переподключение\n      if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n        reconnectAttempts++;\n        const delay = RECONNECT_DELAY * Math.min(reconnectAttempts, 5); // Экспоненциальная задержка\n        console.log(`[ChatWS] Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);\n        reconnectTimer = setTimeout(() => {\n          const newToken = localStorage.getItem('aist_token');\n          if (newToken) {\n            connectChatWebSocket(newToken);\n          }\n        }, delay);\n      } else {\n        console.error('[ChatWS] Max reconnect attempts reached');\n      }\n    };\n    ws.onerror = error => {\n      console.error('[ChatWS] Error:', error);\n    };\n    if (onMessage) listeners.push(onMessage);\n  } catch (e) {\n    console.error('[ChatWS] Connection error:', e);\n    isConnecting = false;\n  }\n}\n\n/**\n * Запустить heartbeat (периодические ping-сообщения)\n */\nfunction startHeartbeat() {\n  stopHeartbeat();\n  heartbeatTimer = setInterval(() => {\n    if (ws && isConnected) {\n      try {\n        ws.send(JSON.stringify({\n          type: 'ping'\n        }));\n      } catch (e) {\n        console.error('[ChatWS] Heartbeat error:', e);\n      }\n    }\n  }, 30000); // Каждые 30 секунд\n}\n\n/**\n * Остановить heartbeat\n */\nfunction stopHeartbeat() {\n  if (heartbeatTimer) {\n    clearInterval(heartbeatTimer);\n    heartbeatTimer = null;\n  }\n}\n\n/**\n * Отправить сообщение через WebSocket\n */\nexport function send(data) {\n  if (ws && isConnected) {\n    try {\n      ws.send(JSON.stringify(data));\n      return true;\n    } catch (e) {\n      console.error('[ChatWS] Send error:', e);\n      pendingMessages.push(data);\n      return false;\n    }\n  } else {\n    pendingMessages.push(data);\n    return false;\n  }\n}\n\n/**\n * Добавить слушателя сообщений\n */\nexport function addListener(listener) {\n  if (!listeners.includes(listener)) {\n    listeners.push(listener);\n  }\n}\n\n/**\n * Удалить слушателя сообщений\n */\nexport function removeListener(listener) {\n  listeners = listeners.filter(l => l !== listener);\n}\n\n/**\n * Отключиться от WebSocket\n */\nexport function disconnect() {\n  stopHeartbeat();\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n  if (ws) {\n    try {\n      ws.close();\n    } catch (e) {\n      console.error('[ChatWS] Close error:', e);\n    }\n    ws = null;\n  }\n  listeners = [];\n  isConnected = false;\n  isConnecting = false;\n  pendingMessages = [];\n  reconnectAttempts = 0;\n}\n\n/**\n * Проверить, подключен ли WebSocket\n */\nexport function isWebSocketConnected() {\n  return isConnected;\n}\n\n/**\n * Проверить, идёт ли подключение\n */\nexport function isWebSocketConnecting() {\n  return isConnecting;\n}\n\n/**\n * Получить количество попыток переподключения\n */\nexport function getReconnectAttempts() {\n  return reconnectAttempts;\n}","map":{"version":3,"names":["getWsUrl","ws","listeners","reconnectTimer","heartbeatTimer","isConnected","isConnecting","pendingMessages","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","RECONNECT_DELAY","connectChatWebSocket","token","onMessage","includes","push","url","encodeURIComponent","WebSocket","onopen","console","log","startHeartbeat","length","msg","shift","send","JSON","stringify","forEach","listener","type","e","error","onmessage","event","data","parse","onclose","code","reason","stopHeartbeat","delay","Math","min","setTimeout","newToken","localStorage","getItem","onerror","setInterval","clearInterval","addListener","removeListener","filter","l","disconnect","clearTimeout","close","isWebSocketConnected","isWebSocketConnecting","getReconnectAttempts"],"sources":["C:/Users/Vladislav/Documents/GitHub/aist-messenger/src/lib/chatWebSocket.js"],"sourcesContent":["/**\n * WebSocket для получения сообщений в реальном времени\n * Улучшенная версия с более надёжной обработкой соединения\n */\nimport { getWsUrl } from './api';\n\nlet ws = null;\nlet listeners = [];\nlet reconnectTimer = null;\nlet heartbeatTimer = null;\nlet isConnected = false;\nlet isConnecting = false;\nlet pendingMessages = [];\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 10;\nconst RECONNECT_DELAY = 3000; // 3 секунды\n\n/**\n * Подключиться к WebSocket\n */\nexport function connectChatWebSocket(token, onMessage) {\n  if (ws && isConnected) {\n    // Если уже подключены, добавляем слушателя\n    if (onMessage && !listeners.includes(onMessage)) {\n      listeners.push(onMessage);\n    }\n    return;\n  }\n\n  if (isConnecting) {\n    // Уже пытаемся подключиться\n    if (onMessage && !listeners.includes(onMessage)) {\n      listeners.push(onMessage);\n    }\n    return;\n  }\n\n  isConnecting = true;\n  const url = `${getWsUrl()}?token=${encodeURIComponent(token)}`;\n\n  try {\n    ws = new WebSocket(url);\n\n    ws.onopen = () => {\n      console.log('[ChatWS] Connected');\n      isConnected = true;\n      isConnecting = false;\n      reconnectAttempts = 0;\n\n      // Запускаем heartbeat для поддержания соединения\n      startHeartbeat();\n\n      // Отправляем отложенные сообщения\n      while (pendingMessages.length > 0) {\n        const msg = pendingMessages.shift();\n        ws.send(JSON.stringify(msg));\n      }\n\n      // Оповещаем слушателей о подключении\n      listeners.forEach(listener => {\n        try {\n          listener({ type: 'connected' });\n        } catch (e) {\n          console.error('[ChatWS] Error in listener:', e);\n        }\n      });\n    };\n\n    ws.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('[ChatWS] Received:', data);\n\n        // Обработка heartbeat\n        if (data.type === 'pong') {\n          return;\n        }\n\n        // Оповещаем всех слушателей\n        listeners.forEach(listener => {\n          try {\n            listener(data);\n          } catch (e) {\n            console.error('[ChatWS] Error in listener:', e);\n          }\n        });\n      } catch (e) {\n        console.error('[ChatWS] Error parsing message:', e);\n      }\n    };\n\n    ws.onclose = (event) => {\n      console.log('[ChatWS] Disconnected, code:', event.code, 'reason:', event.reason);\n      isConnected = false;\n      isConnecting = false;\n      ws = null;\n      stopHeartbeat();\n\n      // Оповещаем слушателей о отключении\n      listeners.forEach(listener => {\n        try {\n          listener({ type: 'disconnected' });\n        } catch (e) {\n          console.error('[ChatWS] Error in listener:', e);\n        }\n      });\n\n      // Автоматическое переподключение\n      if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n        reconnectAttempts++;\n        const delay = RECONNECT_DELAY * Math.min(reconnectAttempts, 5); // Экспоненциальная задержка\n        console.log(`[ChatWS] Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);\n        reconnectTimer = setTimeout(() => {\n          const newToken = localStorage.getItem('aist_token');\n          if (newToken) {\n            connectChatWebSocket(newToken);\n          }\n        }, delay);\n      } else {\n        console.error('[ChatWS] Max reconnect attempts reached');\n      }\n    };\n\n    ws.onerror = (error) => {\n      console.error('[ChatWS] Error:', error);\n    };\n\n    if (onMessage) listeners.push(onMessage);\n  } catch (e) {\n    console.error('[ChatWS] Connection error:', e);\n    isConnecting = false;\n  }\n}\n\n/**\n * Запустить heartbeat (периодические ping-сообщения)\n */\nfunction startHeartbeat() {\n  stopHeartbeat();\n  heartbeatTimer = setInterval(() => {\n    if (ws && isConnected) {\n      try {\n        ws.send(JSON.stringify({ type: 'ping' }));\n      } catch (e) {\n        console.error('[ChatWS] Heartbeat error:', e);\n      }\n    }\n  }, 30000); // Каждые 30 секунд\n}\n\n/**\n * Остановить heartbeat\n */\nfunction stopHeartbeat() {\n  if (heartbeatTimer) {\n    clearInterval(heartbeatTimer);\n    heartbeatTimer = null;\n  }\n}\n\n/**\n * Отправить сообщение через WebSocket\n */\nexport function send(data) {\n  if (ws && isConnected) {\n    try {\n      ws.send(JSON.stringify(data));\n      return true;\n    } catch (e) {\n      console.error('[ChatWS] Send error:', e);\n      pendingMessages.push(data);\n      return false;\n    }\n  } else {\n    pendingMessages.push(data);\n    return false;\n  }\n}\n\n/**\n * Добавить слушателя сообщений\n */\nexport function addListener(listener) {\n  if (!listeners.includes(listener)) {\n    listeners.push(listener);\n  }\n}\n\n/**\n * Удалить слушателя сообщений\n */\nexport function removeListener(listener) {\n  listeners = listeners.filter(l => l !== listener);\n}\n\n/**\n * Отключиться от WebSocket\n */\nexport function disconnect() {\n  stopHeartbeat();\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n  if (ws) {\n    try {\n      ws.close();\n    } catch (e) {\n      console.error('[ChatWS] Close error:', e);\n    }\n    ws = null;\n  }\n  listeners = [];\n  isConnected = false;\n  isConnecting = false;\n  pendingMessages = [];\n  reconnectAttempts = 0;\n}\n\n/**\n * Проверить, подключен ли WebSocket\n */\nexport function isWebSocketConnected() {\n  return isConnected;\n}\n\n/**\n * Проверить, идёт ли подключение\n */\nexport function isWebSocketConnecting() {\n  return isConnecting;\n}\n\n/**\n * Получить количество попыток переподключения\n */\nexport function getReconnectAttempts() {\n  return reconnectAttempts;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}